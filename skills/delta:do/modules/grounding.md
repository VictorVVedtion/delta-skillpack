# Grounding 机制 v1.0

## 核心原则

**每个分析结论必须有代码证据支撑**

### 禁止的判断依据

以下不能作为得出结论的依据：
- 文件名或目录名
- 注释内容
- 函数命名
- 推测或假设
- 统计模式匹配（如"e2e 在文件名中所以是 E2E 测试"）

### 必须的判断依据

结论必须基于以下证据：
- 实际代码执行逻辑
- import/依赖关系
- 数据流向
- 运行时行为特征

---

## 证据要求

### 最小证据数量

| 结论类型 | 最少证据数 | 必须包含 |
|----------|-----------|----------|
| 测试分类 | 3 | 服务启动 + 接口调用 + 断言验证 |
| 覆盖分析 | 2 | 测试代码 + 被测代码的直接引用 |
| 架构判断 | 3 | 模块入口 + 依赖声明 + 调用链 |
| 功能实现 | 2 | 函数定义 + 调用点 |

### 证据格式规范

每条证据必须包含：
1. 文件完整路径
2. 精确行号
3. 实际代码片段（不是描述）

**标准格式**：
```
`{file_path}:{line}` - `{actual_code}`
```

**示例**：
```
`src/auth/login.ts:42` - `const token = jwt.sign(payload, secret)`
```

---

## 证据类型

### 类型 1: 代码证据（权重最高）

直接引用代码文件中的实际执行逻辑。

```markdown
**代码证据**:
1. `src/auth/login.ts:15` - `async function verifyCredentials(email, password)`
2. `src/auth/login.ts:28` - `const user = await db.users.findOne({ email })`
3. `src/auth/login.ts:42` - `return jwt.sign({ userId: user.id }, SECRET)`
```

### 类型 2: NotebookLM 引用（权重高）

从配置的知识库中引用的需求文档、设计文档。

```markdown
**NotebookLM 引用**:
1. [NB] 用户认证需求: "支持 JWT 验证，token 有效期 24 小时"
2. [NB] API 设计规范: "所有认证接口使用 /api/v1/auth 前缀"
```

### 类型 3: 依赖声明（权重中）

import/require 语句，说明模块关系。

```markdown
**依赖声明**:
1. `src/auth/login.ts:1` - `import { sign } from 'jsonwebtoken'`
2. `src/auth/login.ts:3` - `import { db } from '../database'`
```

### 类型 4: 配置文件（权重低）

配置文件内容可能被运行时覆盖，权重较低。

```markdown
**配置证据**（注意：可能被覆盖）:
1. `config/auth.json:5` - `"tokenExpiry": "24h"`
```

---

## 证据权重矩阵

| 类型 | 权重 | 适用场景 | 注意事项 |
|------|------|----------|----------|
| 代码证据 | 100% | 所有代码相关结论 | 最可靠 |
| NotebookLM 引用 | 80% | 需求验证、设计决策 | 需定期更新 |
| 依赖声明 | 60% | 模块关系分析 | 可能有条件导入 |
| 配置文件 | 40% | 运行时行为推断 | 可能被环境变量覆盖 |

---

## 输出模板

### 分析任务输出格式

所有分析任务必须使用以下格式：

```markdown
## 结论声明

[结论内容，使用保守语言]

## 代码证据

1. `{file}:{line}` - `{code}` — {说明}
2. `{file}:{line}` - `{code}` — {说明}
3. `{file}:{line}` - `{code}` — {说明}

## NotebookLM 引用（如有）

1. [NB] {文档标题}: "{引用内容}"

## 置信度

- [x] 高置信度（3+ 条直接代码证据）
- [ ] 中置信度（2 条证据）
- [ ] 低置信度（1 条或间接证据）

## 不确定性声明

⚠️ 以下方面未能验证：
- [列出未验证的点]

⚠️ 注意：此分析基于静态代码阅读，实际运行时行为可能不同。
```

---

## 禁止行为

### 严格禁止的输出模式

以下输出模式被**严格禁止**：

❌ "根据文件名 xxx_e2e_test.go，这是一个 E2E 测试"

❌ "从目录结构看，tests/e2e/ 下的文件应该是 E2E 测试"

❌ "函数名 TestE2E 表明这是端到端测试"

❌ "这是 E2E 测试"（无证据的绝对表述）

❌ "覆盖率达到 100%"（无法验证的绝对数字）

❌ "完全符合要求"（绝对表述）

---

## 允许行为

### 正确的输出示例

✅ **测试分类示例**：

```markdown
## 结论

基于代码分析，`tests/e2e/order_test.go` 是一个真正的 E2E 测试。

## 代码证据

1. `tests/e2e/order_test.go:15` - `node := app.NewTestNode(cfg)` — 启动完整测试节点
2. `tests/e2e/order_test.go:28` - `resp, _ := http.Post(node.URL+"/order", ...)` — 通过 HTTP 接口调用
3. `tests/e2e/order_test.go:42` - `state := node.QueryState(orderID)` — 验证链上状态变化

## 置信度

- [x] 高置信度（3+ 条直接代码证据）

## 不确定性声明

⚠️ 未验证项：
- 测试配置是否接近生产环境
- 是否包含数据库清理逻辑
```

✅ **覆盖分析示例**：

```markdown
## 结论

根据静态代码分析，测试覆盖率约为 75-85%，可能存在遗漏。

## 代码证据

1. `src/auth/login.ts:15-45` 被 `tests/auth.test.ts:20-80` 覆盖
2. `src/auth/logout.ts:10-25` 被 `tests/auth.test.ts:85-100` 覆盖
3. `src/auth/refresh.ts:8-30` — **未找到对应测试文件**

## 置信度

- [ ] 高置信度
- [x] 中置信度（2 条证据）

## 不确定性声明

⚠️ 以下方面未能验证：
- 实际运行时的代码路径覆盖
- 边界条件测试覆盖
- src/auth/refresh.ts 的测试情况
```

---

## 三源验证矩阵

当同时有 NotebookLM 可用时，使用三源验证：

```
┌─────────────────────────────────────────────────────────────┐
│                     置信度验证矩阵                           │
├───────────────────┬───────────────────┬────────────────────┤
│ 代码证据          │ 模型交叉验证        │ NotebookLM 文档    │
│ (Grounding)       │ (Codex vs Gemini)  │ (知识锚点)         │
├───────────────────┼───────────────────┼────────────────────┤
│ file:line 引用    │ 结论一致性检查      │ 需求文档匹配       │
│ 实际代码片段      │ 分歧 → Claude 仲裁  │ 设计文档验证       │
└───────────────────┴───────────────────┴────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 三源一致 → 高置信度                                          │
│ 两源一致 → 中置信度 + 标注不一致来源                         │
│ 一源或无 → 低置信度 + 强制"待验证"标记                       │
└─────────────────────────────────────────────────────────────┘
```

### 三源验证输出示例

```markdown
## 结论

用户认证功能满足需求文档要求。

## 代码证据

1. `src/auth/login.ts:15` - `async function verifyCredentials()` — 实现凭据验证
2. `src/auth/login.ts:42` - `const token = jwt.sign(payload, SECRET, { expiresIn: '24h' })` — JWT 生成

## NotebookLM 引用

3. [NB] 用户认证需求: "支持 JWT 验证，token 有效期 24 小时"

## 模型交叉验证

- Codex 审查：需求覆盖完整 ✓
- Gemini 审查：需求覆盖完整 ✓
- 结论一致：是

## 置信度

- [x] 高置信度（三源验证通过）
```

---

## 与其他模块的关系

| 模块 | 关系 |
|------|------|
| `cross-validation.md` | Grounding 证据作为交叉验证的输入 |
| `test-classification.md` | 测试分类必须提供 Grounding 证据 |
| `review.md` | 审查报告必须遵循 Grounding 格式 |

---

## 版本历史

| 版本 | 变更 |
|------|------|
| v1.0 | 初始版本，定义 Grounding 机制 + NotebookLM 证据类型 + 三源验证矩阵 |
