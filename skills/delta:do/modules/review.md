# 两阶段审查系统 (Two-Phase Review System) v2.0

## 概述

两阶段审查确保实现质量：**阶段 A** 验证规格合规性，**阶段 B** 评估代码质量。双重保障减少遗漏和缺陷。

**v2.0 新增 (v5.4.0)**:
- 独立审查者模式：Codex 实现 → Gemini 审查
- 保守表述原则：禁止绝对表述
- Grounding 要求：所有结论必须有代码证据
- 需求追溯：使用 NotebookLM 验证需求覆盖（可选）

---

## 独立审查者模式 (v5.4 新增)

### 核心原则

**实现者 ≠ 审查者**

```
旧模式 (v5.3.0):
Phase 3: Codex 实现 → Phase 4: Codex 审查
         ↓
    自己审查自己 = 确认偏差

新模式 (v5.4.0):
Phase 3: Codex 实现 → Phase 4: Gemini 独立审查
                              ↓
                      如有分歧 → Claude 仲裁
```

### 适用路由

| 路由 | 实现阶段 | 审查阶段 | 仲裁阶段 |
|------|----------|----------|----------|
| RALPH | Phase 3 (Codex) | Phase 4 (Gemini) | Phase 5 (Claude) |
| ARCHITECT | Phase 4 (Codex) | Phase 5 (Gemini) | Phase 6 (Claude) |

---

## 保守表述原则 (v5.4 新增)

### 禁止的绝对表述

以下表述方式被**严格禁止**：

❌ "这是 E2E 测试"
❌ "覆盖率达到 100%"
❌ "完全符合要求"
❌ "没有任何问题"
❌ "绝对安全"

### 推荐的保守表述

以下表述方式是**推荐的**：

✅ "根据代码分析，这似乎是 E2E 测试，因为..."
✅ "基于静态代码阅读，覆盖率约为 X%"
✅ "发现以下覆盖，但可能存在遗漏"
✅ "在审查范围内未发现严重问题"
✅ "在当前分析深度下，未发现安全隐患"

### 强制不确定性声明

当分析基于静态代码阅读时，必须包含：

```markdown
⚠️ 注意：此分析基于静态代码阅读，实际运行时行为可能不同。
```

当存在未验证的方面时，必须列出：

```markdown
⚠️ 以下方面未能验证：
- 运行时代码路径覆盖
- 边界条件处理
- 并发场景
```

---

## 审查阶段

```
┌─────────────────────────────────────────────────────────────┐
│                     实现完成                                  │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              阶段 A: 规格审查                                 │
│              (Specification Review)                          │
│                                                             │
│  • 需求覆盖检查                                               │
│  • 遗漏功能检测                                               │
│  • 超范围功能警告                                             │
└──────────────────────┬──────────────────────────────────────┘
                       │ 通过
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              阶段 B: 代码质量审查                              │
│              (Code Quality Review)                           │
│                                                             │
│  • 代码风格一致性                                             │
│  • 潜在 Bug 检测                                             │
│  • 性能问题识别                                               │
│  • 安全隐患检查                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 阶段 A: 规格审查

### 目标

验证实现是否完整覆盖原始需求。

### 检查项

#### 1. 需求覆盖 (Requirement Coverage)

| 检查点 | 验证方法 | 严重级别 |
|--------|----------|----------|
| 功能完整性 | 对比计划与实现 | 高 |
| 接口一致性 | 验证 API 签名 | 高 |
| 数据结构 | 检查类型定义 | 中 |
| 边界条件 | 验证边界处理 | 中 |

#### 2. 遗漏检测 (Missing Feature Detection)

```
对比清单:
□ 计划中的每个功能点是否都已实现
□ 错误处理是否完整
□ 日志记录是否添加
□ 文档是否更新
□ 测试是否编写
```

#### 3. 超范围检测 (Scope Creep Detection)

识别不在原始需求中的实现：
- 额外的功能
- 未请求的优化
- 预留的扩展点

**处理**:
- 警告但不阻止
- 记录到审查报告
- 建议是否保留

### 输出格式

```
════════════════════════════════════════════════════════════
📋 阶段 A: 规格审查报告
════════════════════════════════════════════════════════════

✅ 需求覆盖: 8/8 (100%)
┌────────────────────────────────────────────────────────┐
│ ✓ 用户登录功能                                          │
│ ✓ JWT Token 生成                                       │
│ ✓ Token 验证中间件                                      │
│ ✓ 刷新 Token 机制                                       │
│ ✓ 登出功能                                              │
│ ✓ 密码加密存储                                          │
│ ✓ 登录失败限制                                          │
│ ✓ 错误处理                                              │
└────────────────────────────────────────────────────────┘

⚠️ 超范围功能: 1 项
┌────────────────────────────────────────────────────────┐
│ • 添加了记住登录状态功能（未在原需求中）                    │
│   建议: 保留，是合理的增强                                │
└────────────────────────────────────────────────────────┘

📊 规格合规度: 100%
────────────────────────────────────────────────────────────
```

---

## 阶段 B: 代码质量审查

### 目标

评估代码质量，识别潜在问题。

### 审查维度

#### 1. 代码风格 (Code Style)

| 检查点 | 标准 | 自动修复 |
|--------|------|----------|
| 命名规范 | 驼峰/下划线一致 | 否 |
| 缩进格式 | 项目配置 | 是 |
| 空行规则 | 函数间空行 | 是 |
| 注释规范 | JSDoc/类型注释 | 否 |
| 导入顺序 | 分组排序 | 是 |

#### 2. 潜在 Bug (Potential Bugs)

| 类型 | 检测方法 | 严重级别 |
|------|----------|----------|
| 空值处理 | 静态分析 | 高 |
| 类型错误 | TypeScript/类型检查 | 高 |
| 未处理异常 | 控制流分析 | 高 |
| 死代码 | 可达性分析 | 低 |
| 资源泄漏 | 模式匹配 | 中 |

#### 3. 性能问题 (Performance Issues)

| 类型 | 症状 | 建议 |
|------|------|------|
| N+1 查询 | 循环内数据库调用 | 批量查询 |
| 无限循环风险 | 缺少终止条件 | 添加保护 |
| 大数组操作 | 全量加载 | 分页/流处理 |
| 重复计算 | 循环内不变计算 | 提取到循环外 |
| 同步阻塞 | 同步 I/O 操作 | 使用异步 |

#### 4. 安全隐患 (Security Issues)

| 类型 | 风险 | 修复建议 |
|------|------|----------|
| SQL 注入 | 数据泄露 | 参数化查询 |
| XSS | 脚本注入 | 输出转义 |
| 硬编码密钥 | 凭证泄露 | 环境变量 |
| 不安全随机 | 可预测 | crypto.randomBytes |
| 路径遍历 | 文件泄露 | 路径规范化 |

### 输出格式

```
════════════════════════════════════════════════════════════
🔍 阶段 B: 代码质量审查报告
════════════════════════════════════════════════════════════

📁 审查文件: 5 个
  • src/auth/login.ts
  • src/auth/token.ts
  • src/middleware/auth.ts
  • src/types/auth.ts
  • tests/auth.test.ts

────────────────────────────────────────────────────────────
🎨 代码风格: 2 个建议

  [STYLE-001] src/auth/login.ts:42
  导入顺序不一致
  建议: 将第三方导入放在本地导入之前

  [STYLE-002] src/auth/token.ts:15
  函数缺少 JSDoc 注释
  建议: 为公共函数添加文档

────────────────────────────────────────────────────────────
🐛 潜在 Bug: 1 个问题

  [BUG-001] src/middleware/auth.ts:28 ⚠️ 中等
  可能的空值访问: req.headers.authorization
  修复: 添加空值检查

  ```diff
  - const token = req.headers.authorization.split(' ')[1];
  + const authHeader = req.headers.authorization;
  + if (!authHeader) {
  +   return res.status(401).json({ error: 'Missing authorization header' });
  + }
  + const token = authHeader.split(' ')[1];
  ```

────────────────────────────────────────────────────────────
⚡ 性能问题: 0 个

  ✅ 未发现性能问题

────────────────────────────────────────────────────────────
🔒 安全检查: 1 个建议

  [SEC-001] src/auth/token.ts:8 ℹ️ 低
  JWT 密钥建议从环境变量读取
  当前: const SECRET = 'your-secret-key';
  建议: const SECRET = process.env.JWT_SECRET;

────────────────────────────────────────────────────────────
📊 质量评分

  代码风格:    ████████░░ 80%
  Bug 风险:    █████████░ 90%
  性能:        ██████████ 100%
  安全性:      █████████░ 90%

  综合评分:    ████████░░ 90/100 优秀

────────────────────────────────────────────────────────────
📝 改进建议摘要

  必须修复 (0):
    无

  建议修复 (2):
    • 添加空值检查 (BUG-001)
    • JWT 密钥使用环境变量 (SEC-001)

  可选优化 (2):
    • 调整导入顺序 (STYLE-001)
    • 添加函数文档 (STYLE-002)

════════════════════════════════════════════════════════════
```

---

## 审查流程集成

### 触发条件

| 路由 | 触发阶段 | 审查深度 |
|------|----------|----------|
| DIRECT | 跳过 | - |
| PLANNED | Phase 3 | 标准 |
| RALPH | Phase 4 | 完整 |
| ARCHITECT | Phase 5 | 深度 |
| UI_FLOW | Phase 3 | UI 专项 |

### 审查深度

| 深度 | 阶段 A | 阶段 B |
|------|--------|--------|
| 标准 | 基础覆盖检查 | 常见问题检查 |
| 完整 | 详细覆盖 + 边界 | 全面质量评估 |
| 深度 | 架构一致性验证 | 深度安全 + 性能 |
| UI 专项 | UI 需求覆盖 | 可访问性 + 响应式 |

---

## 问题严重级别

### 级别定义

| 级别 | 图标 | 说明 | 处理要求 |
|------|------|------|----------|
| 严重 | 🔴 | 阻断性问题 | 必须修复 |
| 高 | 🟠 | 重要问题 | 强烈建议修复 |
| 中 | 🟡 | 潜在问题 | 建议修复 |
| 低 | ℹ️ | 改进建议 | 可选优化 |

### 阻断规则

以下情况阻止任务完成：
- 存在任何 🔴 严重级别问题
- 规格覆盖度 < 80%
- 安全评分 < 70%

---

## 自动修复

### 支持自动修复的问题

| 问题类型 | 修复方式 |
|----------|----------|
| 格式问题 | Prettier/ESLint --fix |
| 导入排序 | 自动重排 |
| 简单空值检查 | 添加 `?.` 或 `??` |
| 未使用变量 | 添加 `_` 前缀或删除 |

### 自动修复流程

```
1. 检测可自动修复的问题
2. 显示修复预览
3. 用户确认后应用
4. 重新运行检查验证
```

---

## 配置选项

在 `.skillpackrc` 中配置：

```json
{
  "review": {
    "enabled": true,
    "auto_fix": true,
    "strict_mode": false,
    "custom_rules": [],
    "ignore_patterns": [
      "*.test.ts",
      "*.spec.ts"
    ],
    "thresholds": {
      "coverage_min": 80,
      "security_min": 70,
      "quality_min": 60
    }
  }
}
```

| 选项 | 默认值 | 说明 |
|------|--------|------|
| `enabled` | true | 启用审查 |
| `auto_fix` | true | 自动修复简单问题 |
| `strict_mode` | false | 严格模式（更严格的规则） |
| `ignore_patterns` | [] | 忽略的文件模式 |
| `thresholds` | {...} | 评分阈值 |

---

## Grounding 要求 (v5.4 新增)

### 审查报告必须包含代码证据

所有审查结论必须遵循 `grounding.md` 的格式要求：

```markdown
## 问题发现

### [BUG-001] 空值访问风险

**严重性**: 中等
**位置**: `src/auth/login.ts:28`
**代码**: `const token = req.headers.authorization.split(' ')[1]`
**问题**: 未检查 authorization 是否存在
**置信度**: 高（直接代码证据）
```

### 禁止无证据的结论

❌ "代码质量良好" （无具体证据）
❌ "测试覆盖完整" （未逐一验证）
❌ "安全性符合要求" （未进行安全检查）

---

## 需求追溯 (v5.4 新增，可选)

### 启用条件

当配置了 `knowledge.default_notebook` 时，审查阶段会：

1. 查询 NotebookLM 获取相关需求文档
2. 将需求文档注入审查 prompt
3. 验证实现与需求的匹配度

### 需求追溯报告格式

```markdown
## 需求追溯

| 需求项 | 来源 | 状态 | 证据 |
|--------|------|------|------|
| JWT token 有效期 24h | [NB] 认证需求 v2.1 | ✅ 已实现 | `token.ts:15` |
| 支持刷新 token | [NB] 认证需求 v2.1 | ❌ 未实现 | - |
| 登录失败限制 | [NB] 安全规范 | ⚠️ 部分实现 | `login.ts:42` |
```

---

## 与其他模块的关系

| 模块 | 关系 |
|------|------|
| `grounding.md` | 审查结论必须遵循 Grounding 格式 |
| `cross-validation.md` | 审查是交叉验证的一部分 |
| `test-classification.md` | 测试覆盖审查使用此分类标准 |
| `mcp-dispatch.md` | 定义审查阶段的模型分配 |

---

## 版本历史

| 版本 | 变更 |
|------|------|
| **v2.0** | 独立审查者模式 + 保守表述原则 + Grounding 要求 + 需求追溯 |
| v1.0 | 初始版本，两阶段审查 |
