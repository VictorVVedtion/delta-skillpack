# 交叉验证机制 v1.0

## 核心原则

**实现者 ≠ 审查者**

避免确认偏差，关键结论需要多源验证。

---

## 问题背景

### 自我印证陷阱

```
旧架构 (v5.3.0):
Phase 3: Codex (CLI) 实现 → Phase 4: Codex (CLI) 审查
                             ↓
                      自己审查自己 = 确认偏差

问题：
- 实现者倾向于认为自己的实现是正确的
- 审查者使用相同的"思维模式"
- 容易忽略系统性错误
```

### 新架构 (v5.4.0)

```
新架构:
Phase 3: Codex (CLI) 实现 → Phase 4: Gemini (CLI) 独立审查
                                    ↓
                            如有分歧 → Claude 仲裁
```

---

## 置信度等级

| 等级 | 证据来源数 | 输出处理 |
|------|-----------|----------|
| 高置信度 | 3+ | 可确定性输出 |
| 中置信度 | 2 | 输出但标注置信度 |
| 低置信度 | 1 | 标记为"待验证" |

---

## 验证方法

### 方法 1: 多模型交叉验证

用于 RALPH/ARCHITECT 路由的审查阶段。

**执行流程（CLI 优先模式）**：

```
1. Codex 完成实现 → 输出 A
   命令: codex exec "<实现任务>" --full-auto

2. Gemini 独立审查 → 输出 B
   命令: gemini "@<输出文件> <审查任务>" -s --yolo

3. 对比 A 和 B:
   - 一致 → 高置信度，直接输出
   - 不一致 → Claude 仲裁
```

**仲裁规则**：
- 读取双方的具体分歧点
- 逐一验证代码证据
- 采纳有更强证据支撑的结论
- 如证据强度相当，采用保守结论

### 方法 2: 多角度证据验证

用于分析类任务（架构分析、测试覆盖等）。

```
证据来源:
1. 代码静态分析 - 实际执行逻辑（权重最高）
2. 依赖图分析 - import/require 关系
3. 配置文件分析 - 运行时配置

验证规则:
- 至少 2 个来源支持同一结论
- 如有矛盾，以代码静态分析为准
- 配置文件可能被覆盖，权重较低
```

### 方法 3: 三源验证（含 NotebookLM）

当配置了 NotebookLM 知识库时启用。

```
三源验证架构:
┌─────────────────────────────────────────────────────────────┐
│                     置信度验证矩阵                           │
├───────────────────┬───────────────────┬────────────────────┤
│ 代码证据          │ 模型交叉验证        │ NotebookLM 文档    │
│ (Grounding)       │ (Codex vs Gemini)  │ (知识锚点)         │
├───────────────────┼───────────────────┼────────────────────┤
│ file:line 引用    │ 结论一致性检查      │ 需求文档匹配       │
│ 实际代码片段      │ 分歧 → Claude 仲裁  │ 设计文档验证       │
└───────────────────┴───────────────────┴────────────────────┘
```

---

## 独立审查流程

### RALPH 路由（新版 v5.4.0）

```
Phase 1 (20%): 深度分析    ← Claude (直接执行)
Phase 2 (40%): 规划        ← Claude (直接执行)
Phase 3 (65%): 执行子任务  ← Codex (CLI: codex exec --full-auto)
Phase 4 (85%): 独立审查    ← Gemini (CLI: gemini -s --yolo) ← 新增！
Phase 5 (100%): 仲裁验证   ← Claude (直接执行) ← 新增！
```

### ARCHITECT 路由（新版 v5.4.0）

```
Phase 1 (15%): 架构分析    ← Gemini (CLI: gemini -s --yolo)
Phase 2 (25%): 架构设计    ← Claude (直接执行)
Phase 3 (40%): 实施规划    ← Claude (直接执行)
Phase 4 (65%): 分阶段实施  ← Codex (CLI: codex exec --full-auto)
Phase 5 (85%): 独立审查    ← Gemini (CLI: gemini -s --yolo) ← 调整！
Phase 6 (100%): 仲裁验证   ← Claude (直接执行) ← 新增！
```

---

## CLI 调用示例

### Phase 3: Codex 实现

```bash
codex exec "任务: 实现用户登录接口

相关文件:
- src/auth/login.ts
- src/models/user.ts

要求:
1. 验证用户凭据
2. 生成 JWT token
3. 处理错误情况

输出格式:
- 创建/修改的文件列表
- 每个文件的完整代码" --full-auto
```

### Phase 4: Gemini 独立审查

```bash
gemini "@.skillpack/current/3_subtask_auth.md 审查代码实现

审查重点:
1. 需求是否完全覆盖
2. 代码质量和最佳实践
3. 潜在 Bug 和安全问题
4. 与原始需求的偏差

输出格式:
- 问题列表（严重性 + 文件:行号 + 具体问题）
- 改进建议
- 是否通过审查（是/否/有条件通过）" -s --yolo
```

### Phase 4 扩展: 含 NotebookLM 查询

当配置了 `knowledge.default_notebook` 时：

```
# Step 1: 查询 NotebookLM 获取需求文档
mcp__notebooklm-mcp__notebook_query(
    notebook_id="{default_notebook}",
    query="关于用户认证功能的需求和验收标准"
)

# Step 2: 将需求文档注入 Gemini 审查 prompt
gemini "@.skillpack/current/3_subtask_auth.md 审查代码实现

参考需求文档（来自 NotebookLM）:
{notebook_query_result}

审查重点:
1. 实现是否满足需求文档中的要求
2. 是否有需求遗漏
3. 是否有超范围实现
4. 代码质量和最佳实践" -s --yolo
```

---

## 分歧处理流程

当 Codex 和 Gemini 结论不一致时：

### Step 1: 记录分歧点

```markdown
┌─────────────────────────────────────────────────────────────┐
│ 分歧项: JWT token 过期时间设置                               │
├─────────────────────────────────────────────────────────────┤
│ Codex 结论: token 过期时间设置为 24 小时，符合需求           │
│ Codex 证据: `src/auth/token.ts:15` -                        │
│   `jwt.sign(payload, secret, { expiresIn: '24h' })`         │
├─────────────────────────────────────────────────────────────┤
│ Gemini 结论: token 过期时间应为 1 小时，与需求文档不符       │
│ Gemini 证据: 需求文档中提到"token 有效期 1 小时"            │
└─────────────────────────────────────────────────────────────┘
```

### Step 2: Claude 仲裁

```markdown
仲裁步骤:
1. 读取 Codex 引用的代码
2. 读取 Gemini 引用的需求文档
3. 验证实际需求是什么
4. 选择正确的结论

仲裁过程:
- 检查 NotebookLM 中的需求文档
- 发现需求确实是"token 有效期 24 小时"
- Gemini 可能查看了旧版需求

仲裁结果: 采纳 Codex 结论
```

### Step 3: 输出仲裁结果

```markdown
┌─────────────────────────────────────────────────────────────┐
│ 仲裁结果: token 过期时间设置为 24 小时，符合需求             │
├─────────────────────────────────────────────────────────────┤
│ 采纳: Codex                                                  │
│ 理由: NotebookLM 中的最新需求文档确认"token 有效期 24 小时"  │
│       Gemini 可能引用了过时的需求版本                        │
├─────────────────────────────────────────────────────────────┤
│ 置信度: 高                                                   │
│ 证据: [NB] 用户认证需求 v2.1: "JWT token 有效期 24 小时"     │
└─────────────────────────────────────────────────────────────┘
```

---

## 审查阶段输出格式

### Gemini 审查报告模板

```markdown
# 独立审查报告

## 审查摘要

| 项目 | 结果 |
|------|------|
| 审查文件 | {file_count} 个 |
| 需求覆盖 | {coverage}% |
| 发现问题 | {issue_count} 个 |
| 审查结论 | {通过 / 有条件通过 / 不通过} |

## 需求追溯（如有 NotebookLM）

| 需求项 | 状态 | 证据 |
|--------|------|------|
| {需求1} | ✅ 已实现 | `file:line` |
| {需求2} | ❌ 未实现 | - |
| {需求3} | ⚠️ 部分实现 | `file:line` |

## 问题列表

### [问题编号] {问题标题}

- **严重性**: {高 / 中 / 低}
- **位置**: `{file}:{line}`
- **问题描述**: {描述}
- **代码片段**: `{code}`
- **建议修复**: {修复方案}

## 改进建议

1. {建议1}
2. {建议2}

## 置信度声明

- 此审查基于静态代码阅读
- 以下方面未能验证: {列表}
```

---

## 仲裁验证阶段

### 触发条件

仲裁验证阶段在以下情况触发：

1. Codex 实现与 Gemini 审查存在分歧
2. Gemini 审查发现严重问题（高严重性）
3. 需求覆盖率 < 80%
4. 安全相关问题

### Claude 仲裁职责

```
仲裁职责:
1. 读取 Codex 实现的输出
2. 读取 Gemini 审查的输出
3. 识别分歧点
4. 验证双方证据
5. 做出最终决定
6. 输出仲裁报告
```

### 仲裁报告模板

```markdown
# 仲裁验证报告

## 分歧点

| # | 分歧项 | Codex 结论 | Gemini 结论 |
|---|--------|------------|-------------|
| 1 | {item} | {结论} | {结论} |

## 仲裁决定

### 分歧 #1: {分歧项}

**采纳**: {Codex / Gemini}

**理由**:
{详细理由，引用具体代码}

**证据**:
1. `{file}:{line}` - `{code}`
2. [NB] {文档}: "{引用}"

## 最终结论

| 项目 | 结果 |
|------|------|
| 置信度 | {高 / 中 / 低} |
| 通过审查 | {是 / 否 / 有条件} |
| 后续行动 | {行动项} |
```

---

## 禁止行为

❌ 不验证就采纳任一模型的结论

❌ 因为 Codex 是实现者就优先采纳

❌ 忽略分歧直接输出

❌ 无证据支持的仲裁决定

❌ 使用 MCP 调用 Codex/Gemini（必须使用 CLI）

---

## 配置选项

在 `.skillpackrc` 中配置交叉验证行为：

```json
{
  "cross_validation": {
    "enabled": true,
    "require_arbitration_on_disagreement": true,
    "min_confidence_for_auto_pass": "high",
    "auto_query_notebook_before_review": true
  }
}
```

---

## 与其他模块的关系

| 模块 | 关系 |
|------|------|
| `grounding.md` | 交叉验证使用 Grounding 格式的证据 |
| `mcp-dispatch.md` | 定义审查阶段的模型分配 |
| `review.md` | 交叉验证是审查的一部分 |
| `config-schema.md` | 定义 cross_validation 配置项 |

---

## 版本历史

| 版本 | 变更 |
|------|------|
| v1.0 | 初始版本，定义交叉验证机制 + 独立审查者模式 + 仲裁流程 + 三源验证 |
