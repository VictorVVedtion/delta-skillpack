# /do Skill - 执行指令 v3.0.0

当用户调用 `/do <任务>` 时，按以下流程执行：

---

## 核心原则

1. **立即行动** - 不要只是解释，要真正执行任务
2. **量化决策** - 使用评分系统，决策有据可循
3. **持续追踪** - 使用 TodoWrite 追踪进度
4. **检查点保存** - 关键节点自动保存状态
5. **错误恢复** - 遇到错误时提供恢复选项
6. **两阶段审查** - 规格合规 + 代码质量双保障

---

## Step 0: 知识库初始化（强制）

在任何阶段开始前：

1. **检查配置**：读取项目根目录的 `.skillpackrc` 文件
2. **如果存在 `knowledge.default_notebook`**：
   ```
   ════════════════════════════════════════════════════════════
   📚 知识库初始化
   ════════════════════════════════════════════════════════════
   Notebook ID: {notebook_id}
   正在查询相关文档...
   ────────────────────────────────────────────────────────────
   ```
3. **调用 NotebookLM**：使用 `mcp__notebooklm-mcp__notebook_query` 查询
4. **注入上下文**：将查询结果用于后续所有阶段

**铁律：不查询知识库就不开始执行（如已配置）**

---

## Step 1: 解析参数

从用户输入中提取：
- `task`: 任务描述
- `quick_mode`: `-q` 或 `--quick`
- `deep_mode`: `-d` 或 `--deep`
- `explain_only`: `-e` 或 `--explain`
- `resume`: `--resume [task_id]`

---

## Step 2: 检查恢复模式

如果包含 `--resume`：

### 恢复流程

1. 读取 `.skillpack/current/checkpoint.json`
2. 验证检查点完整性
3. 输出恢复信息：
   ```
   ════════════════════════════════════════════════════════════
   🔄 从检查点恢复
   ════════════════════════════════════════════════════════════
   任务: {task_description}
   恢复点: Phase {N}, {详细位置}
   已完成: {completed_percentage}%
   继续执行...
   ────────────────────────────────────────────────────────────
   ```
4. 从检查点继续执行

---

## Step 3: 复杂度评分

### 强制模式覆盖

- 如果 `quick_mode=true` → 使用 DIRECT 路由
- 如果 `deep_mode=true` → 使用 RALPH 路由

### 6 维度评分（参考 modules/scoring.md）

对任务描述进行评分：

| 维度 | 权重 | 评估内容 |
|------|------|----------|
| 范围广度 | 25% | 影响文件数量 |
| 依赖复杂度 | 20% | 模块间依赖关系 |
| 技术深度 | 20% | 技术难度/新技术 |
| 风险等级 | 15% | 破坏性/可逆性 |
| 时间估算 | 10% | 预估完成时间 |
| UI 复杂度 | 10% | 界面/交互复杂度 |

### 快速信号调整

| 关键词 | 调整 |
|--------|------|
| `typo`, `拼写`, `注释` | -10 分 |
| `重构`, `refactor` | +15 分 |
| `系统`, `架构` | +20 分 |
| `完整`, `从零` | +25 分 |

---

## Step 4: 路由决策（参考 modules/routing.md）

| 总分 | 路由 | 阶段数 |
|------|------|--------|
| 0-20 | DIRECT | 1 |
| 21-45 | PLANNED | 3 |
| 46-70 | RALPH | 4 |
| 71-100 | ARCHITECT | 5 |
| UI 信号 | UI_FLOW | 3 |

### --explain 模式输出

```
════════════════════════════════════════════════════════════
📊 任务复杂度分析
════════════════════════════════════════════════════════════
复杂度评分: {总分}/100

┌────────────────────────────────────────┐
│ 范围广度:    {条形图} {scope}/25       │
│ 依赖复杂度:  {条形图} {dependency}/20  │
│ 技术深度:    {条形图} {technical}/20   │
│ 风险等级:    {条形图} {risk}/15        │
│ 时间估算:    {条形图} {time}/10        │
│ UI 复杂度:   {条形图} {ui}/10          │
└────────────────────────────────────────┘

🚀 推荐路由: {路由名称}
📝 路由原因: {原因说明}
────────────────────────────────────────────────────────────
```

如果 `explain_only=true`，输出后停止。

---

## Step 5: 准备执行环境

1. 确保 `.skillpack/current/` 目录存在
2. 清空目录中的旧文件
3. 初始化检查点

---

## 执行策略

### DIRECT（直接执行）

**适用**: 0-20 分，简单任务

```
Phase 1 (100%): 执行
  └── 直接完成任务，输出简短摘要
```

**行为**:
1. 使用 TodoWrite 创建简单任务列表
2. 直接使用工具完成任务
3. 保存输出到 `.skillpack/current/output.txt`

---

### PLANNED（计划执行）

**适用**: 21-45 分，中等复杂度任务

```
Phase 1 (30%): 规划
  ├── 分析需求
  ├── 列出实施步骤（3-7步）
  └── 保存到 1_plan.md

Phase 2 (60%): 实现
  ├── 逐步执行计划
  ├── 更新 Todo 状态
  ├── 保存检查点
  └── 保存到 2_implementation.md

Phase 3 (100%): 两阶段审查
  ├── 阶段 A: 规格审查
  ├── 阶段 B: 代码质量审查
  └── 保存到 3_review.md
```

---

### RALPH（复杂任务自动化）

**适用**: 46-70 分，复杂任务

```
Phase 1 (20%): 深度分析
  ├── 任务分解
  ├── 依赖关系识别
  ├── 风险评估
  └── 保存到 1_analysis.md

Phase 2 (40%): 规划
  ├── 子任务详细规划
  ├── 执行顺序确定
  └── 保存到 2_plan.md

Phase 3 (75%): 执行子任务
  ├── 按依赖顺序执行
  ├── 每个子任务保存检查点
  └── 保存到 3_subtask_*.md

Phase 4 (100%): 综合审查
  ├── 两阶段审查
  ├── 集成验证
  └── 保存到 4_review.md
```

---

### ARCHITECT（架构优先）

**适用**: 71-100 分，超复杂任务

```
Phase 1 (15%): 架构分析
  ├── 系统全局分析
  ├── 现有架构评估
  └── 保存到 1_architecture_analysis.md

Phase 2 (30%): 架构设计
  ├── 目标架构设计
  ├── 技术选型
  └── 保存到 2_architecture_design.md

Phase 3 (50%): 实施规划
  ├── 详细任务分解
  ├── 迁移策略
  └── 保存到 3_implementation_plan.md

Phase 4 (80%): 分阶段实施
  ├── 按阶段执行
  ├── 持续集成验证
  └── 保存到 4_phase_*.md

Phase 5 (100%): 验收审查
  ├── 架构一致性验证
  ├── 深度审查
  └── 保存到 5_acceptance_review.md
```

---

### UI_FLOW（UI 流程）

**适用**: UI 信号，前端任务

```
Phase 1 (30%): UI 设计
  ├── 组件结构设计
  ├── 样式规范
  └── 保存到 1_ui_design.md

Phase 2 (60%): 实现
  ├── 组件开发
  ├── 样式实现
  └── 保存到 2_implementation.md

Phase 3 (100%): 预览验证
  ├── 视觉验证
  ├── 两阶段审查
  └── 保存到 3_preview.md
```

---

## 阶段提示格式

**每个阶段开始时必须输出**：

```
════════════════════════════════════════════════════════════
📍 Phase {N}/{TOTAL}: {阶段名称} | {路由} 路由
🤖 执行模型: {Claude/Codex/Gemini}
════════════════════════════════════════════════════════════
进度: {进度条} {百分比}%

📊 复杂度评分: {总分}/100
┌────────────────────────────────────────┐
│ 范围广度:    {条形图} {scope}/25       │
│ 依赖复杂度:  {条形图} {dependency}/20  │
│ 技术深度:    {条形图} {technical}/20   │
│ 风险等级:    {条形图} {risk}/15        │
│ 时间估算:    {条形图} {time}/10        │
│ UI 复杂度:   {条形图} {ui}/10          │
└────────────────────────────────────────┘

上一阶段: {状态} {结果}
当前任务: {目标}
输出文件: {路径}
────────────────────────────────────────────────────────────
```

---

## 检查点保存（参考 modules/checkpoint.md）

### 自动保存时机

- 每个阶段完成时
- 每个子任务完成时
- 发生可恢复错误时

### 保存内容

```json
{
  "task_id": "uuid",
  "route": "RALPH",
  "complexity_score": 58,
  "current_phase": 3,
  "completed_phases": [1, 2],
  "subtasks": {...},
  "files_modified": [...],
  "timestamp": "..."
}
```

---

## 两阶段审查（参考 modules/review.md）

### 阶段 A: 规格审查

- 需求覆盖检查
- 遗漏功能检测
- 超范围功能警告

### 阶段 B: 代码质量审查

- 代码风格一致性
- 潜在 Bug 检测
- 性能问题识别
- 安全隐患检查

### 输出格式

```
════════════════════════════════════════════════════════════
📋 阶段 A: 规格审查报告
════════════════════════════════════════════════════════════
✅ 需求覆盖: {covered}/{total} ({percentage}%)
⚠️ 超范围功能: {count} 项
────────────────────────────────────────────────────────────

════════════════════════════════════════════════════════════
🔍 阶段 B: 代码质量审查报告
════════════════════════════════════════════════════════════
🎨 代码风格: {count} 个建议
🐛 潜在 Bug: {count} 个问题
⚡ 性能问题: {count} 个
🔒 安全检查: {count} 个建议

📊 综合评分: {score}/100
────────────────────────────────────────────────────────────
```

---

## 错误处理（参考 modules/recovery.md）

### 自动恢复

| 错误类型 | 策略 |
|----------|------|
| 网络超时 | 等待 5 秒重试，最多 3 次 |
| 语法错误 | 自动尝试修复，最多 2 次 |
| 文件锁定 | 等待 2 秒重试，最多 5 次 |

### 恢复选项菜单

```
════════════════════════════════════════════════════════════
⚠️ 执行错误
════════════════════════════════════════════════════════════
阶段: Phase {N} - {阶段名称}
错误类型: {错误分类}
错误消息: {错误信息}
────────────────────────────────────────────────────────────

📋 恢复选项:
  [1] 🔄 继续 - 从失败点继续执行
  [2] 🔁 重试 - 重新执行当前步骤
  [3] ⏪ 回滚 - 撤销本次所有变更
  [4] ⏭️ 跳过 - 跳过当前阶段
  [5] ⛔ 中止 - 终止执行

请选择 (1-5):
```

---

## 任务完成输出

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 任务完成

📋 任务: {task_description}
📊 复杂度: {score}/100 ({路由})
🚀 执行路径: {阶段描述}

📁 变更文件:
  - path/to/file1.ts (新增)
  - path/to/file2.ts (修改)

📝 摘要:
  {2-3句话总结}

📄 输出文件:
  - .skillpack/current/1_*.md
  - .skillpack/current/2_*.md
  - ...
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## AI 模型分工

### ⚠️ 铁律：MCP 调用强制约束

**以下规则不可违反，必须严格执行：**

1. **禁止替代规则**：当路由-模型分配矩阵指定使用 Codex 或 Gemini 时，**禁止 Claude 自己执行该阶段的核心任务**。必须调用对应的 MCP 工具。

2. **阶段检查点**：进入需要调用 MCP 的阶段时，必须：
   - 先输出"🤖 调用: {模型名称}"提示
   - 然后**立即调用** MCP 工具
   - **不得跳过**或用 Claude 自己完成

3. **失败处理**：如果 MCP 调用失败：
   - 重试最多 2 次
   - 如果仍然失败，**询问用户**是否允许 Claude 接管
   - **不得静默降级**到 Claude 执行

4. **验证机制**：每个阶段完成后，在输出中明确标注实际使用的模型：
   ```
   ✅ Phase {N} 完成 | 执行模型: {实际使用的模型}
   ```

### MCP 服务器配置

确保以下 MCP 服务器已配置（通过 `claude mcp add` 添加）：

```bash
# Codex MCP Server - 代码开发和审查
claude mcp add codex-cli -- npx -y codex-mcp-server

# Gemini MCP Server - 架构分析和 UI/UX
claude mcp add gemini-cli -- npx -y gemini-mcp-tool
```

### 可用 MCP 工具

| MCP 服务器 | 工具名称 | 功能 |
|------------|----------|------|
| **codex-cli** | `mcp__codex-cli__codex` | AI 编码助手，支持会话和模型选择 |
| **codex-cli** | `mcp__codex-cli__review` | AI 代码审查 |
| **gemini-cli** | `mcp__gemini-cli__ask-gemini` | 向 Gemini 请求分析（支持 @文件路径） |
| **gemini-cli** | `mcp__gemini-cli__sandbox-test` | 沙箱环境代码测试 |

### 模型能力定位

| 模型 | 核心优势 | 最佳场景 |
|------|----------|----------|
| **Claude Opus 4.5** | 精细控制、代码质量、任务协调 | 规划、Debug、重构、协调 |
| **Codex (GPT-5.2)** | 强推理、复杂开发、生态成熟 | 新功能实现、API集成、脚本 |
| **Gemini 3 Pro** | 超长上下文、多模态、视觉理解 | UI/UX、项目分析、看图写码 |

### 路由-模型分配矩阵

#### DIRECT (0-20分)

| 阶段 | 模型 | 命令 | 理由 |
|------|------|------|------|
| 执行 | **Claude** | 直接执行 | 精细修改，快速响应 |

#### PLANNED (21-45分)

| 阶段 | 模型 | MCP 工具 | 理由 |
|------|------|----------|------|
| Phase 1: 规划 | **Claude** | 直接执行 | 任务分析和协调 |
| Phase 2: 实现 | **Codex** | `mcp__codex-cli__codex` | 复杂功能开发 |
| Phase 3: 审查 | **Codex** | `mcp__codex-cli__review` | 专业代码审查 |

#### RALPH (46-70分)

| 阶段 | 模型 | MCP 工具 | 理由 |
|------|------|----------|------|
| Phase 1: 分析 | **Claude** | 直接执行 | 任务分解和依赖识别 |
| Phase 2: 规划 | **Claude** | 直接执行 | 子任务规划 |
| Phase 3: 执行 | **Codex** | `mcp__codex-cli__codex` | 批量功能开发 |
| Phase 4: 审查 | **Codex** | `mcp__codex-cli__codex` | 综合审查 |

**🚨 RALPH Phase 3/4 强制执行流程：**

进入 Phase 3 或 Phase 4 时，**必须**按以下步骤执行：

1. 输出阶段提示，明确标注 `🤖 执行模型: Codex`
2. 准备调用参数：
   - `prompt`: 包含详细任务描述、相关文件路径、期望输出
   - `cwd`: 设置为项目根目录
   - `sandbox`: 设置为 `workspace-write`
3. **立即调用** `mcp__codex-cli__codex`
4. 等待 Codex 返回结果
5. 验证并保存输出

**禁止行为**：
- ❌ Claude 自己使用 Write/Edit 工具写代码
- ❌ 跳过 MCP 调用直接完成任务
- ❌ MCP 失败后不询问用户就自己接管

#### ARCHITECT (71-100分)

| 阶段 | 模型 | MCP 工具 | 理由 |
|------|------|----------|------|
| Phase 1: 架构分析 | **Gemini** | `mcp__gemini-cli__ask-gemini` | 整个项目分析，超长上下文 |
| Phase 2: 架构设计 | **Claude** | 直接执行 | 精细设计决策 |
| Phase 3: 实施规划 | **Claude** | 直接执行 | 详细任务分解 |
| Phase 4: 分阶段实施 | **Codex** | `mcp__codex-cli__codex` | 批量开发 |
| Phase 5: 验收审查 | **Codex** | `mcp__codex-cli__codex` | 深度审查 |

**🚨 ARCHITECT 强制执行流程：**

- **Phase 1**: 必须调用 `mcp__gemini-cli__ask-gemini`，使用 `@./` 语法引入项目文件
- **Phase 4/5**: 必须调用 `mcp__codex-cli__codex`

#### UI_FLOW

| 阶段 | 模型 | MCP 工具 | 理由 |
|------|------|----------|------|
| Phase 1: UI设计 | **Gemini** | `mcp__gemini-cli__ask-gemini` | 多模态，看图写码 |
| Phase 2: 实现 | **Gemini** | `mcp__gemini-cli__ask-gemini` | UI组件开发 |
| Phase 3: 预览 | **Claude** | 直接执行 | 验证和微调 |

**🚨 UI_FLOW 强制执行流程：**

- **Phase 1/2**: 必须调用 `mcp__gemini-cli__ask-gemini`
- 可使用 `@./src/components` 等语法让 Gemini 理解现有组件结构

### MCP 工具调用示例

#### Codex 开发调用
```xml
<invoke name="mcp__codex-cli__codex">
  <parameter name="prompt">实现用户认证功能，包括登录、注册和JWT验证</parameter>
</invoke>
```

#### Codex 代码审查
```xml
<invoke name="mcp__codex-cli__review">
  <parameter name="prompt">审查最近的代码变更</parameter>
</invoke>
```

#### Gemini 架构分析
```xml
<invoke name="mcp__gemini-cli__ask-gemini">
  <parameter name="prompt">@./src 分析整个项目架构，识别模块依赖关系</parameter>
</invoke>
```

#### Gemini UI 设计
```xml
<invoke name="mcp__gemini-cli__ask-gemini">
  <parameter name="prompt">@./src/components 设计现代化登录页面，React + Tailwind</parameter>
</invoke>
```

### 调用输出

```
════════════════════════════════════════════════════════════
🤖 调用: {Claude/Codex/Gemini} | {路由} 路由 Phase {N}
════════════════════════════════════════════════════════════
MCP 工具: {工具名称}
参数: {prompt 内容}
────────────────────────────────────────────────────────────
```

---

## 进度追踪

**必须使用 TodoWrite 工具追踪任务进度**：

1. 开始执行前，创建任务列表
2. 每个阶段开始时，更新为 `in_progress`
3. 每个阶段完成时，标记为 `completed`
4. 同时只有一个任务处于 `in_progress` 状态
