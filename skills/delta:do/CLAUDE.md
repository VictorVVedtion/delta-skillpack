# /do Skill - 执行指令 v5.2.0

当用户调用 `/do <任务>` 时，按以下流程执行：

---

## v5.2 新特性

| 特性 | 说明 |
|------|------|
| **异步并行执行** | 使用 `run_in_background: true` 同时启动多个任务 |
| **DAG 依赖分析** | 自动构建任务依赖图，识别可并行任务 |
| **波次管理** | 按依赖分组，同一波次内并行执行 |
| **跨模型并行** | Codex + Gemini 同时工作 |
| **TaskOutput 轮询** | 定期检查后台任务状态，收集结果 |
| **并行恢复** | 中断后可恢复正在执行的并行任务 |

## v5.0/5.1 特性

| 特性 | 说明 |
|------|------|
| **原子检查点** | SHA-256 校验和 + write-rename 模式 |
| **CLI 直接调用** | `--cli` 标志绕过 MCP |
| **自动 CLI 降级** | MCP 超时后自动切换到 CLI |
| **结构化日志** | JSONL 格式执行日志 |
| **任务粒度控制** | 自动拆分大任务（< 5000 tokens） |
| **智能降级策略** | 文档任务可快速降级，代码任务需确认 |

---

## 核心原则

1. **立即行动** - 不要只是解释，要真正执行任务
2. **量化决策** - 使用评分系统，决策有据可循
3. **MCP 强制执行** - 指定模型必须通过 MCP 调用，禁止替代
4. **循环执行** - RALPH/ARCHITECT 使用 Stop Hook 迭代直到完成
5. **持续追踪** - 使用 TodoWrite 追踪进度
6. **原子检查点** - SHA-256 校验 + 多版本备份，关键节点安全保存
7. **两阶段审查** - 规格合规 + 代码质量双保障
8. **结构化日志** - JSONL 格式记录执行过程
9. **异步并行** - 无依赖任务并行执行，显著提升效率 (v5.2)

---

## Step 0: 知识库初始化（强制）

在任何阶段开始前：

1. **检查配置**：读取项目根目录的 `.skillpackrc` 文件
2. **如果存在 `knowledge.default_notebook`**：
   ```
   ════════════════════════════════════════════════════════════
   📚 知识库初始化
   ════════════════════════════════════════════════════════════
   Notebook ID: {notebook_id}
   正在查询相关文档...
   ────────────────────────────────────────────────────────────
   ```
3. **调用 NotebookLM**：使用 `mcp__notebooklm-mcp__notebook_query` 查询
4. **注入上下文**：将查询结果用于后续所有阶段

**铁律：不查询知识库就不开始执行（如已配置）**

---

## Step 1: 解析参数

从用户输入中提取：
- `task`: 任务描述
- `quick_mode`: `-q` 或 `--quick`
- `deep_mode`: `-d` 或 `--deep`
- `parallel_mode`: `--parallel` (强制启用并行)
- `no_parallel_mode`: `--no-parallel` (强制禁用并行)
- `explain_only`: `-e` 或 `--explain`
- `resume`: `--resume [task_id]`

---

## Step 2: 检查恢复模式

如果包含 `--resume`：

### 恢复流程

1. 检查 `.claude/ralph-delta.local.md` 状态文件
2. 如存在，读取并验证状态
3. 输出恢复信息：
   ```
   ════════════════════════════════════════════════════════════
   🔄 从检查点恢复
   ════════════════════════════════════════════════════════════
   任务: {task_description}
   路由: {route}
   恢复点: Phase {N}, 迭代 {iteration}
   已完成: {completed_percentage}%
   继续执行...
   ────────────────────────────────────────────────────────────
   ```
4. 从检查点继续执行

---

## Step 3: 复杂度评分

### 强制模式覆盖

- 如果 `quick_mode=true` → 使用 DIRECT 路由
- 如果 `deep_mode=true` → 使用 RALPH 路由

### 6 维度评分（参考 modules/scoring.md）

| 维度 | 权重 | 评估内容 |
|------|------|----------|
| 范围广度 | 25% | 影响文件数量 |
| 依赖复杂度 | 20% | 模块间依赖关系 |
| 技术深度 | 20% | 技术难度/新技术 |
| 风险等级 | 15% | 破坏性/可逆性 |
| 时间估算 | 10% | 预估完成时间 |
| UI 复杂度 | 10% | 界面/交互复杂度 |

### 快速信号调整

| 关键词 | 调整 |
|--------|------|
| `typo`, `拼写`, `注释` | -10 分 |
| `重构`, `refactor` | +15 分 |
| `系统`, `架构` | +20 分 |
| `完整`, `从零` | +25 分 |

---

## Step 4: 路由决策

| 总分 | 路由 | 执行模式 |
|------|------|----------|
| 0-20 | DIRECT | 线性 |
| 21-45 | PLANNED | 线性 |
| 46-70 | RALPH | **循环** |
| 71-100 | ARCHITECT | **循环** |
| UI 信号 | UI_FLOW | 线性 |

### --explain 模式输出

```
════════════════════════════════════════════════════════════
📊 任务复杂度分析
════════════════════════════════════════════════════════════
复杂度评分: {总分}/100

┌────────────────────────────────────────┐
│ 范围广度:    {条形图} {scope}/25       │
│ 依赖复杂度:  {条形图} {dependency}/20  │
│ 技术深度:    {条形图} {technical}/20   │
│ 风险等级:    {条形图} {risk}/15        │
│ 时间估算:    {条形图} {time}/10        │
│ UI 复杂度:   {条形图} {ui}/10          │
└────────────────────────────────────────┘

🚀 推荐路由: {路由名称} ({线性/循环})
📝 路由原因: {原因说明}
────────────────────────────────────────────────────────────
```

如果 `explain_only=true`，输出后停止。

---

## Step 5: 准备执行环境

1. 确保 `.skillpack/current/` 目录存在
2. 清空目录中的旧文件
3. 初始化检查点

### 循环模式额外步骤 (RALPH/ARCHITECT)

4. 创建状态文件 `.claude/ralph-delta.local.md`：

```markdown
# Delta Loop State

## Meta
- Task ID: {uuid}
- Route: {RALPH/ARCHITECT}
- Started: {timestamp}
- Last Updated: {timestamp}

## Iteration
- Current: 1
- Max Allowed: 20
- Status: IN_PROGRESS

## Progress
- Current Phase: 1
- Completed Phases: []
- Current Subtask: 0 / {total}

## Pending Work
{初始任务描述}

## Completed Work
(none)

## Promise
<!-- 任务完成后在此处设置完成标记 -->
```

---

## 执行策略

### DIRECT（直接执行）- 线性

**适用**: 0-20 分，简单任务

```
Phase 1 (100%): 执行
  └── Claude 直接完成任务
```

**行为**:
1. 使用 TodoWrite 创建简单任务列表
2. 直接使用工具完成任务
3. 保存输出到 `.skillpack/current/output.txt`

---

### PLANNED（计划执行）- 线性

**适用**: 21-45 分，中等复杂度任务

```
Phase 1 (30%): 规划        ← Claude
Phase 2 (60%): 实现        ← Codex (MCP)
Phase 3 (100%): 两阶段审查 ← Codex (MCP)
```

#### Phase 2/3: MCP 强制调用

**进入 Phase 2 时必须**：

1. 输出阶段提示，明确标注 `🤖 执行模型: Codex (MCP 强制调用)`
2. 准备调用参数
3. **立即调用** `mcp__codex-cli__codex`
4. **禁止** Claude 自己使用 Write/Edit 工具完成实现

---

### RALPH（复杂任务自动化）- 循环

**适用**: 46-70 分，复杂任务

```
Phase 1 (20%): 深度分析    ← Claude
Phase 2 (40%): 规划        ← Claude
Phase 3 (75%): 执行子任务  ← Codex (MCP) [循环迭代]
Phase 4 (100%): 综合审查   ← Codex (MCP)
```

#### 循环执行机制

1. **状态文件**：创建 `.claude/ralph-delta.local.md`
2. **迭代执行**：每次迭代更新状态文件
3. **Stop Hook**：未完成时拦截退出，重新注入 Prompt
4. **完成标记**：完成后设置 `<promise>TASK_COMPLETE</promise>`

#### Phase 3: 子任务循环

每个子任务完成后：
1. 更新状态文件中的 `Current Subtask`
2. 更新 `Completed Work`
3. 检查是否全部完成

**全部子任务完成后**，进入 Phase 4。

#### Phase 3/4: MCP 强制调用

```
🚨 RALPH Phase 3/4 强制执行流程：

1. 输出阶段提示，明确标注 `🤖 执行模型: Codex (MCP 强制调用)`
2. 准备调用参数：
   - prompt: 包含详细任务描述、相关文件路径、期望输出
3. 立即调用 mcp__codex-cli__codex
4. 等待 Codex 返回结果
5. 更新状态文件
6. 验证并保存输出

禁止行为：
❌ Claude 自己使用 Write/Edit 工具写代码
❌ 跳过 MCP 调用直接完成任务
❌ MCP 失败后不询问用户就自己接管
```

---

### ARCHITECT（架构优先）- 循环

**适用**: 71-100 分，超复杂任务

```
Phase 1 (15%): 架构分析    ← Gemini (MCP)
Phase 2 (30%): 架构设计    ← Claude
Phase 3 (50%): 实施规划    ← Claude
Phase 4 (80%): 分阶段实施  ← Codex (MCP) [循环迭代]
Phase 5 (100%): 验收审查   ← Codex (MCP)
```

#### Phase 1: Gemini 架构分析

```
🚨 ARCHITECT Phase 1 强制执行流程：

1. 输出阶段提示，明确标注 `🤖 执行模型: Gemini (MCP 强制调用)`
2. 准备调用参数：
   - prompt: @{project_path} 分析整个项目架构...
3. 立即调用 mcp__gemini-cli__ask-gemini
4. 等待 Gemini 返回结果
5. 保存到 1_architecture_analysis.md

禁止行为：
❌ Claude 自己进行架构分析
❌ 跳过 Gemini 调用
```

#### Phase 4/5: Codex 实施

同 RALPH 的 MCP 强制调用流程。

---

### UI_FLOW（UI 流程）- 线性

**适用**: UI 信号，前端任务

```
Phase 1 (30%): UI设计   ← Gemini (MCP)
Phase 2 (60%): 实现     ← Gemini (MCP)
Phase 3 (100%): 预览    ← Claude
```

#### Phase 1/2: Gemini UI 开发

```
🚨 UI_FLOW Phase 1/2 强制执行流程：

1. 输出阶段提示，明确标注 `🤖 执行模型: Gemini (MCP 强制调用)`
2. 准备调用参数：
   - prompt: @{components_path} 设计/实现 UI...
3. 立即调用 mcp__gemini-cli__ask-gemini
4. 等待 Gemini 返回结果
5. 保存输出

禁止行为：
❌ Claude 自己实现 UI 代码
❌ 跳过 Gemini 调用
```

---

## MCP 调用模板

### Codex 开发调用

```python
prompt = f"""
任务: {task_description}

相关文件:
{list_of_files}

要求:
{requirements}

输出格式:
- 创建/修改的文件列表
- 每个文件的完整代码
"""

mcp__codex-cli__codex(
    prompt=prompt,
    sandbox="workspace-write"
)
```

### Gemini 架构分析

```python
prompt = f"""
@{project_root_path}

分析整个项目架构:
1. 模块依赖关系
2. 技术栈识别
3. 架构模式识别
4. 改进建议
"""

mcp__gemini-cli__ask-gemini(
    prompt=prompt
)
```

### Gemini UI 开发

```python
prompt = f"""
@{components_path}

任务: {ui_task}

设计要求:
{design_requirements}

技术栈: {tech_stack}
"""

mcp__gemini-cli__ask-gemini(
    prompt=prompt
)
```

---

## 阶段提示格式

**每个阶段开始时必须输出**：

```
════════════════════════════════════════════════════════════
📍 Phase {N}/{TOTAL}: {阶段名称} | {路由} 路由
🤖 执行模型: {Claude/Codex/Gemini} {(MCP 强制调用) 或 (直接执行)}
════════════════════════════════════════════════════════════
进度: {进度条} {百分比}%

📊 复杂度评分: {总分}/100
┌────────────────────────────────────────┐
│ 范围广度:    {条形图} {scope}/25       │
│ 依赖复杂度:  {条形图} {dependency}/20  │
│ 技术深度:    {条形图} {technical}/20   │
│ 风险等级:    {条形图} {risk}/15        │
│ 时间估算:    {条形图} {time}/10        │
│ UI 复杂度:   {条形图} {ui}/10          │
└────────────────────────────────────────┘

上一阶段: {状态} {结果}
当前任务: {目标}
输出文件: {路径}
────────────────────────────────────────────────────────────
```

---

## MCP 失败处理

### 指数退避重试 (v5.0)

MCP 调用失败时，先自动重试：

```yaml
retry_policy:
  max_attempts: 3
  backoff:
    initial_delay_ms: 1000    # 首次重试延迟 1 秒
    multiplier: 2             # 每次延迟翻倍
    max_delay_ms: 30000       # 最大延迟 30 秒
    jitter: true              # 添加随机抖动
```

**重试序列**: 立即 → 1s → 2s → 4s → 询问用户

### 错误分类

| 级别 | 错误类型 | 处理策略 |
|------|----------|----------|
| L1 | 网络超时、速率限制、服务暂不可用 | 自动指数退避重试 |
| L2 | 认证过期、配额超限、模型过载 | 询问用户确认 |
| L3 | 请求无效、内容过滤、未知错误 | 报告错误，用户决策 |

### 智能降级策略 (v5.0)

根据任务类型决定降级行为：

| 任务类型 | 降级策略 | 说明 |
|----------|----------|------|
| 文档更新 | `auto` | 可自动降级到 Claude |
| 配置修改 | `auto` | 可自动降级到 Claude |
| 代码实现 | `require_confirmation` | 必须用户确认 |
| 架构设计 | `require_confirmation` | 必须用户确认 |
| UI 开发 | `require_confirmation` | 必须用户确认 |

### 用户选择界面

自动重试失败后，显示选项：

```
╔════════════════════════════════════════════════════════════╗
║ ⚠️ MCP 调用失败                                            ║
╠════════════════════════════════════════════════════════════╣
║ 模型: {Codex/Gemini}                                       ║
║ 工具: {tool_name}                                          ║
║ 错误: {error_message}                                      ║
║ 重试: {retry_count}/3 (已用尽)                             ║
╠════════════════════════════════════════════════════════════╣
║ 📋 恢复选项:                                               ║
║   [1] 🔄 重试 - 再次尝试 MCP 调用                          ║
║   [2] 🔀 Claude 接管 - 允许 Claude 完成此阶段              ║
║   [3] ⏭️ 跳过 - 跳过此阶段                                 ║
║   [4] ⛔ 中止 - 终止执行                                   ║
╚════════════════════════════════════════════════════════════╝
请选择 (1-4):
```

**重要**：代码任务必须获得用户选择后才能继续，**禁止静默降级**。

---

## 状态文件更新规范

### 每阶段完成后

更新 `.claude/ralph-delta.local.md`：

1. 添加阶段到 `Completed Phases`
2. 更新 `Current Phase`
3. 更新 `Completed Work` 摘要
4. 更新 `Pending Work`
5. 更新 `Last Updated`

### 每子任务完成后

1. 更新 `Current Subtask`
2. 添加到 `Completed Work`

### 全部完成时

**必须设置完成标记**：

```markdown
## Promise
<promise>TASK_COMPLETE</promise>

## Completion Summary
- Total Iterations: {count}
- Total Duration: {time}
- Files Modified: {count}
- Review Score: {score}/100
```

---

## 阶段完成输出

**成功：**
```
✅ Phase {N} 完成
├── 执行模型: {实际使用的模型}
├── MCP 工具: {tool_name 或 N/A}
├── 耗时: {duration}
└── 输出: {output_file}
```

**降级执行：**
```
⚠️ Phase {N} 完成 (降级执行)
├── 原计划模型: {planned_model}
├── 实际模型: Claude (用户授权降级)
├── 降级原因: {reason}
└── 输出: {output_file}
```

---

## 任务完成输出

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 任务完成

📋 任务: {task_description}
📊 复杂度: {score}/100 ({路由})
🔄 迭代次数: {iterations} (仅循环模式)
🚀 执行路径: {阶段描述}

📁 变更文件:
  - path/to/file1.ts (新增)
  - path/to/file2.ts (修改)

📝 摘要:
  {2-3句话总结}

📄 输出文件:
  - .skillpack/current/1_*.md
  - .skillpack/current/2_*.md
  - ...
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 错误处理

### 自动恢复

| 错误类型 | 策略 |
|----------|------|
| 网络超时 | 等待 5 秒重试，最多 3 次 |
| 语法错误 | 自动尝试修复，最多 2 次 |
| 文件锁定 | 等待 2 秒重试，最多 5 次 |
| MCP 失败 | 询问用户选择恢复选项 |

### 恢复选项菜单

```
════════════════════════════════════════════════════════════
⚠️ 执行错误
════════════════════════════════════════════════════════════
阶段: Phase {N} - {阶段名称}
错误类型: {错误分类}
错误消息: {错误信息}
────────────────────────────────────────────────────────────

📋 恢复选项:
  [1] 🔄 继续 - 从失败点继续执行
  [2] 🔁 重试 - 重新执行当前步骤
  [3] ⏪ 回滚 - 撤销本次所有变更
  [4] ⏭️ 跳过 - 跳过当前阶段
  [5] ⛔ 中止 - 终止执行

请选择 (1-5):
```

---

## 进度追踪

**必须使用 TodoWrite 工具追踪任务进度**：

1. 开始执行前，创建任务列表
2. 每个阶段开始时，更新为 `in_progress`
3. 每个阶段完成时，标记为 `completed`
4. 同时只有一个任务处于 `in_progress` 状态

---

## 两阶段审查

### 阶段 A: 规格审查

- 需求覆盖检查
- 遗漏功能检测
- 超范围功能警告

### 阶段 B: 代码质量审查

- 代码风格一致性
- 潜在 Bug 检测
- 性能问题识别
- 安全隐患检查

### 输出格式

```
════════════════════════════════════════════════════════════
📋 阶段 A: 规格审查报告
════════════════════════════════════════════════════════════
✅ 需求覆盖: {covered}/{total} ({percentage}%)
⚠️ 超范围功能: {count} 项
────────────────────────────────────────────────────────────

════════════════════════════════════════════════════════════
🔍 阶段 B: 代码质量审查报告
════════════════════════════════════════════════════════════
🎨 代码风格: {count} 个建议
🐛 潜在 Bug: {count} 个问题
⚡ 性能问题: {count} 个
🔒 安全检查: {count} 个建议

📊 综合评分: {score}/100
────────────────────────────────────────────────────────────
```

---

## 原子检查点机制 (v5.0)

### 写入流程

```
保存检查点
    │
    ▼
┌─────────────────────────────────────────────┐
│ Step 1: 生成临时文件                         │
│   文件名: checkpoint.json.tmp.{random_id}   │
└─────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────┐
│ Step 2: 写入完整数据 + 计算 SHA-256          │
└─────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────┐
│ Step 3: 原子重命名 (mv tmp → checkpoint.json)│
└─────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────┐
│ Step 4: 更新校验和文件 (.sha256)             │
└─────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────┐
│ Step 5: 轮转备份 (保留 3 个版本)             │
└─────────────────────────────────────────────┘
```

### 校验失败恢复

1. 尝试 `.backup.1` → `.backup.2` → `.backup.3`
2. 所有备份无效时提供选项：
   - 从历史记录恢复
   - 放弃检查点，重新开始
   - 手动检查文件

---

## 结构化日志 (v5.0)

### 日志位置

`.skillpack/current/execution.log.jsonl`

### 日志格式

```json
{"ts":"2026-01-19T10:00:00Z","level":"INFO","phase":1,"model":"gemini","event":"phase_start","msg":"开始架构分析"}
{"ts":"2026-01-19T10:05:00Z","level":"INFO","phase":1,"model":"gemini","event":"mcp_call","msg":"调用 ask-gemini","metrics":{"tokens":1500}}
{"ts":"2026-01-19T10:15:00Z","level":"INFO","phase":1,"model":"gemini","event":"phase_complete","msg":"架构分析完成","metrics":{"duration_ms":900000}}
```

### 事件类型

| 事件 | 说明 |
|------|------|
| `phase_start` | 阶段开始 |
| `phase_complete` | 阶段完成 |
| `mcp_call` | MCP 工具调用 |
| `mcp_retry` | MCP 重试 |
| `mcp_fallback` | MCP 降级 |
| `checkpoint_write` | 检查点保存 |
| `error` | 错误发生 |

---

## 任务粒度控制 (v5.0)

### MCP 调用限制

| 限制项 | 阈值 | 处理策略 |
|--------|------|----------|
| Prompt 长度 | < 5000 tokens | 自动拆分 |
| 文件数量 | < 10 个 | 分批处理 |
| 代码行数 | < 500 行/次 | 按模块拆分 |
| 复杂度评分 | < 40/子任务 | 进一步拆分 |

### 自动拆分策略

大任务自动拆分为多个 MCP 调用：

```
原始任务: "实现用户认证系统"
    │
    ▼
拆分后:
├── MCP Call 1: 创建用户模型和数据库 Schema
├── MCP Call 2: 实现注册接口
├── MCP Call 3: 实现登录接口
├── MCP Call 4: 实现 JWT 验证中间件
└── MCP Call 5: 添加单元测试
```

---

## 并行执行 (v5.2 新增)

### 启用条件

并行执行在以下条件下启用：
1. 配置 `parallel.enabled = true`，或
2. 用户指定 `--parallel` 参数

### 并行执行流程

```
1. 分析子任务依赖关系，构建 DAG
   ↓
2. 计算执行波次（无依赖任务分到同一波次）
   ↓
3. 并行启动当前波次的所有任务
   - 使用 Task 工具 + run_in_background: true
   - 同一消息中发送多个 Task 调用
   ↓
4. TaskOutput 轮询收集结果
   - poll_interval_seconds 间隔检查
   - 更新检查点中的任务状态
   ↓
5. 当前波次完成后，进入下一波次
   ↓
6. 回到 Step 3 直到全部完成
```

### 并行启动示例

在 Phase 3 (执行子任务) 中，如果有 3 个无依赖子任务：

```markdown
════════════════════════════════════════════════════════════
🚀 Wave 1/2 开始 | 并行启动 3 个任务
════════════════════════════════════════════════════════════
├── [Codex] subtask_1: 创建用户模型
├── [Codex] subtask_2: 创建认证服务
└── [Gemini] subtask_3: 设计登录表单
────────────────────────────────────────────────────────────
```

**Claude 在单条消息中同时发送 3 个 Task 工具调用**，每个都设置 `run_in_background: true`。

### 结果收集

```markdown
════════════════════════════════════════════════════════════
⏳ Wave 1 执行中 | 已用时间: 45s
════════════════════════════════════════════════════════════
[●●●●●] subtask_1 - 创建用户模型 (Codex)    - ✅ 完成 (38s)
[●●●●○] subtask_2 - 创建认证服务 (Codex)    - 运行中
[●●●○○] subtask_3 - 设计登录表单 (Gemini)   - 运行中
────────────────────────────────────────────────────────────
进度: 1/3 完成 | 下次轮询: 5s
────────────────────────────────────────────────────────────
```

### 串行模式

当 `parallel.enabled = false` 或用户指定 `--no-parallel` 时，行为与 v5.1 一致，子任务串行执行。

---

## 模块引用

| 模块 | 功能 | 版本 |
|------|------|------|
| `modules/scoring.md` | 6 维度加权评分系统 | v1.0 |
| `modules/routing.md` | 路由决策矩阵 | v1.0 |
| `modules/checkpoint.md` | 原子检查点与恢复机制 | **v3.0** |
| `modules/recovery.md` | 错误处理与恢复策略 | **v2.2** |
| `modules/review.md` | 两阶段审查系统 | v1.0 |
| `modules/mcp-dispatch.md` | MCP 强制调用与并行调度 | **v5.2** |
| `modules/loop-engine.md` | 循环执行引擎 | **v5.2** |
| `modules/config-schema.md` | 配置验证规范 | **v5.0** |
| `modules/logging.md` | 结构化日志系统 | v1.0 |
